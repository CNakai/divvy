from .errors import InvalidBBLearnSubmittedFilenameError
from .file import File


class BBLearnSubmittedFile(File):
    @classmethod
    def __segment_bblearn_filename(cls, bblearn_filename):
        """Returns the four constituent pieces a valid BBLearn filename

        The format of a valid filename is:
        <assignment name>_<username>_attempt_<timestamp>_<name as submitted>

        If the passed filename is not valid, an exception is raised

        """
        try:
            assignment_and_username, timestamp_and_filename = \
                bblearn_filename.split('_attempt_')
            assignment, username = assignment_and_username.rsplit('_',
                                                                  maxsplit=1)
            timestamp, filename = timestamp_and_filename.split('_', maxsplit=1)
        except ValueError:
            raise InvalidBBLearnSubmittedFilenameError(bblearn_filename)

        return {
            'name': filename,
            'author': username,
            'timestamp': timestamp,
            'for_assignment': assignment,
        }

    @classmethod
    def from_bblearn_filename(cls, bblearn_filename,
                              bblearn_assignment_download_zip):
        return cls(
            **cls.__segment_bblearn_filename(bblearn_filename),
            location=bblearn_assignment_download_zip
        )

    def __init__(self, name, author, timestamp, for_assignment, location):
        self.__for_assignment = for_assignment
        super().__init__(name, author, timestamp, location)

    def __str__(self):
        return self.bblearn_name

    def __additional_str_parts(self):
        return [f"for_assignment='{self.for_assignment}'"]

    @property
    def for_assignment(self):
        """The assignment the file was submitted for"""
        return self.__for_assignment

    @property
    def bblearn_name(self):
        """The filename generated by BBLearn from the name as submitted"""
        return "_".join([
            self.for_assignment, self.author,
            'attempt',
            self.timestamp, self.name
        ])

    def for_same_assignment_as(self, other):
        return self.for_assignment == other.for_assignment
