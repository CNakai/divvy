import click
from email.message import EmailMessage
from mimetypes import guess_type
from os import mkdir
from pathlib import Path
from shutil import copy, copytree, make_archive, rmtree
import smtplib
from sys import exit
import toml
from zipfile import is_zipfile, ZipFile

from divvy.assignment import Assignment
from .gradingmap import GradingMap


def set_up_command_group():
    global command_group
    __grading.add_command(create_map)
    __grading.add_command(package)
    __grading.add_command(send)
    command_group = __grading


@click.group(name='grading')
def __grading():
    """Commands for preparing and sending grading assignments"""
    pass


@click.command()
@click.argument(
    'participants_location',
    type=click.Path(readable=True, resolve_path=True)
)
@click.argument(
    'gradees_per_grader',
    type=int
)
@click.option(
    '--output-dir', '-d',
    type=click.Path(file_okay=False, writable=True, resolve_path=True),
    default=".",
    help="""
    Directory where the grading assignment file should be saved.  If one is not
    given, it defaults to the current working directory.
    """
)
@click.option(
    '--seed', '-s',
    help="""
    Seed for the random number generator so the same grading map can be
    generated again if the file is lost but the seed is known.
    """
)
def create_map(participants_location, gradees_per_grader, output_dir, seed):
    """
    PARTICIPANTS-LOCATION must be one of:
    1) A BBLearn assignment download zip file
    2) A Divvy assignment directory
    3) A text file containing a list of participant identifiers; one per line

    The generated grading assignment file is a JSON file containing a
    dictionary which maps the ids of graders to the ids of the students whose
    submissions they will grade.

    Each grader will be assigned GRADEES-PER-GRADER gradees.


    The file will be named with the same name as the PARTICIPANTS-LOCATION with
    the file extension removed and "_grading_map.json" added to the end.

    """
    participants_location = Path(participants_location)
    output_dir = Path(output_dir)
    gm = GradingMap.from_participants_location(participants_location,
                                               gradees_per_grader, seed)

    save_path = output_dir / Path(
        participants_location.stem + '_grading_map.json'
    )
    if save_path.exists():
        print(f"The file {save_path} already exists!")
        click.confirm("Would you like to OVERWRITE this file and continue?",
                      abort=True)

    gm.save(save_path)


unassigned_gradees_notice = """
NOTICE: There were {0} students who had a submission in the submission file but
        who were not listed in the grading assignment file as a gradee.

        This likely due to either:

            1) running the 'package' command with a submission file or a
            grading assignment file that are mismatched, i.e. using a 'hwk1'
            submission file but a 'hwk2' grading assignment file or vice versa;
            this is likely if the number of unassigned gradees is high.

            2) running the 'package' command with a "fresher" version of the
            submission file than was used to generate the grading assignment
            file; you can either regenerate the grading assignment file (if you
            want to include the unassigned gradees in the grading process) or
            ignore this warning (if those students, say, made their submissions
            after the due date and you want to exclude them).
"""


@click.command()
@click.argument('submission-location')
@click.option(
    '--grading-map-file', '-m', 'grading_map_file',
    type=click.Path(exists=True, dir_okay=False,
                    readable=True, resolve_path=True),
    help="""
    A file which contains a grading map as generated by the "divvy grading
    create-map" command.

    If one is not supplied, a grading map will be generated but not saved.
    """
)
@click.option(
    '--gradees-per-grader', '-n', 'gradees_per_grader',
    type=int,
    help="""
    The number of gradees to assign each grader if a GRADING-MAP-FILE is not
    supplied.
    """
)
@click.option(
    '--seed', '-s',
    help="""
    Seed for the random number generator so the same grading map can be
    generated again if the file is lost but the seed is known.

    Only used if GRADING-MAP-FILE is not supplied.
    """
)
@click.option(
    '--per-gradee', '--rubric', '-e', 'per_gradee_files',
    multiple=True,
    type=click.Path(exists=True, dir_okay=False,
                    readable=True, resolve_path=True),
    help="""
    A file which should be included once for each gradee (like a blank rubric).
    This file will be copied into every gradee's submission directory in every
    grader's zip file.

    When it is copied, the filename will be changed according to the following
    scheme:

    Original name:    "hwk1_rubric.abc"
    After copy:       "hwk1_rubric__gradee_<gradee identifier>.abc"

    In the sample zip file structure shown above, the files named with the
    pattern "hwk1_rubric__gradee_<gradee identifier>.docx" would all be the
    result of adding the option "-e hwk1_rubric.docx".

    This option can be given multiple times.
    """
)
@click.option(
    '--per-grader', '-r', 'per_grader_files',
    multiple=True,
    type=click.Path(exists=True, dir_okay=False,
                    readable=True, resolve_path=True),
    help="""
    A file which should be included once for each grader (like grading
    instructions).  This file will be copied into the directory that contains
    all the gradee submission directories in every grader's zip file.

    When it is copied, the filename will be changed according to the following
    scheme:

    Original name:    "grading_instructions.abc"
    After copy:       "grading_instructions__grader_<grader identifier>.abc"

    In the sample zip file structure shown above, the files named
    "grading_instructions__grader_jkl321.docx" and
    "self_evaluation__grader_jkl321.docx" would have come from adding the
    options "-r grading_instructions.docx" and "-r self_evaluation.docx".
    """
)
@click.option(
    '--output-dir', '-d',
    type=click.Path(file_okay=False, writable=True, resolve_path=True),
    help="""
    The directory into which the zipfiles should be placed.

    By default, the created zip files will be placed in a directory created in
    the working directory of the script with the same name as the
    SUBMISSION-LOCATION, minus any file extensions, with "grading_zips_for__"
    added to the beginning.
    """
)
def package(submission_location, grading_map_file, gradees_per_grader, seed,
            per_gradee_files, per_grader_files, output_dir):
    """
    SUBMISSION-LOCATION must be either:
    1) A BBLearn assignment download zip file
    2) A Divvy assignment directory

    A zip file will be created for each grader named according to the following
    scheme:
        <grader identifier>__grading_for_<assignment name>
    Where the <assignment name> comes from the name of the SUBMISSION-LOCATION
    minus any file extensions

    Each of these zip files will contain a directory with the same name as the
    zip within which everything else will be contained.  This container
    directory will contain copies of student submission directories of the
    gradees designated for the grader the zip file is named after as well as a
    copy of any file passed as a PER-GRADER-FILE.  Additionally, a copy of
    every PER-GRADEE-FILE will be placed into each of the student submission
    directories in the container directory.

    This can be seen directly in the directory tree for a sample zip file for
    the grader with the BBLearn username "jkl321" shown below.  This zip file
    would have resulted from an invocation of this command like the following:
    \b
        divvy grading package hwk1 hwk1_grading_map.json \\
        -r grading_instructions.docx -r self_evaluation.docx \\
        -e hwk1_rubric.docx

    \b
    jkl321__grading_for_hwk1.zip
    └── jkl321__grading_for_hwk1
        ├── grading_instructions__grader_jkl321.docx
        ├── self_evaluation__grader_jkl321.docx
        ├── ghi789
        │   ├── submission_file3.txt
        │   ├── submission_file2.txt
        │   ├── submission_file1.txt
        │   └── hwk1_rubric__gradee_ghi789.docx
        ├── def456
        │   ├── submission_file3.txt
        │   ├── submission_file2.txt
        │   ├── submission_file1.txt
        │   └── hwk1_rubric__gradee_def456.docx
        └── abc123
            ├── submission_file3.txt
            ├── submission_file2.txt
            ├── submission_file1.txt
            └── hwk1_rubric__gradee_abc126.docx

    """
    # TODO: Correct documentation inaccuracy above: add timestamp after gradee
    submission_location = Path(submission_location)
    per_grader_files = [] if not per_grader_files else per_grader_files
    per_gradee_files = [] if not per_gradee_files else per_gradee_files

    if grading_map_file:
        gm = GradingMap.load_from_file(grading_map_file)
        grading_map_is_new = False
    else:
        if not gradees_per_grader:
            print("If a GRADING-MAP-FILE is not provided, you must specify",
                  "the number of GRADEES-PER-GRADER.")
            exit(1)
        gm = GradingMap.from_participants_location(submission_location,
                                                   gradees_per_grader, seed)
        grading_map_is_new = True

    if submission_location.is_dir():
        attempts = Assignment.from_divvy_assignment_dir(submission_location)
    elif is_zipfile(submission_location):
        attempts = Assignment.from_bblearn_assignment_download_zip(
            submission_location
        )

    if not output_dir:
        output_dir = Path('grading_zips_for__' + attempts.name)

    if not output_dir.exists():
        print(f"Creating directory {output_dir}")
        mkdir(output_dir)
        print("Done!")
    elif len(list(output_dir.iterdir())) != 0:
        print(f"The directory {output_dir} is not empty!")
        exit(1)

    grading_map_save_path = (output_dir.parent /
                             Path(attempts.name + '_grading_map.json'))
    if grading_map_is_new and grading_map_save_path.exists():
        print(f"The file {grading_map_save_path} already exists!")
        click.confirm("Would you like to OVERWRITE this file and continue?",
                    abort=True)
        gm.save(grading_map_save_path)

    for grader in gm.graders:
        grader_path = Path(f"{grader}__grading_for_{attempts.name}")
        grader_zip = ZipFile((output_dir / grader_path).with_suffix('.zip'),
                             mode='w')
        for gradee in gm.gradees_for(grader):
            gradee_path = Path(gradee)
            for file in attempts.latest_for(gradee).files:
                file_path = Path(file.name)
                file_data = file.get_data()
                grader_zip.writestr(str(grader_path/gradee_path/file_path),
                                    file_data)
            for file in per_gradee_files:
                file_path = Path(append_in_file_name(Path(file).name,
                                                     f"__gradee_{gradee}"))
                file_data = Path(file).read_bytes()
                grader_zip.writestr(str(grader_path/gradee_path/file_path),
                                    file_data)

        for file in per_grader_files:
            file_path = Path(append_in_file_name(Path(file).name,
                                                 f"__grader_{grader}"))
            file_data = Path(file).read_bytes()
            grader_zip.writestr(str(grader_path/file_path), file_data)


def append_in_file_name(file_name, appendage):
    name, file_extensions = file_name.split('.', maxsplit=1)
    return f"{name}{appendage}.{file_extensions}"


@click.command()
@click.argument(
    'packaged-grading-path',
    type=click.Path(exists=True, file_okay=False,
                    readable=True, resolve_path=True)
)
@click.option(
    '--email-file', '-e',
    type=click.Path(exists=True, dir_okay=False,
                    readable=True, resolve_path=True),
    help="""
    A TOML file containing keys for any of the other options.  If the other
    options are also passed, they override what is in the file.
    """
)
@click.option(
    '--dry-run', '-d',
    is_flag=True,
    default=False,
    help="""
    Causes a list of e-mail address to which messages would have been sent to
    be displayed.
    """
)
def send(packaged_grading_path, email_file, dry_run):
    """
    The zip files generated by the 'divvy grading package' command which are
    located at the PACKAGED-GRADING-PATH are sent to the student designated in
    the name of the zip file.

    The e-mails will be sent via your NAU IRIS e-mail.
    """

    necessary_config_properties = ['username', 'password', 'address',
                                   'subject', 'message']
    try:
        email_config = toml.load(email_file)
        for prop in necessary_config_properties:
            if not email_config.get(prop):
                print("Your email configuration file must have a value for",
                      f"'prop'")
                exit(1)

    except toml.TomlDecodeError as toml_err:
        print("Something is wrong with your email configuration file.")
        print(toml_err)
        exit(1)


    # Connect to the server
    with smtplib.SMTP('iris.nau.edu', 587) as iris:
        try:
            iris.ehlo()
            iris.starttls()
        except Exception as connection_err:
            print("Something went wrong connecting to iris "
                  "(not login credential related):")
            print(connection_err)
            exit(1)
        try:
            iris.login(email_config['username'], email_config['password'])
        except Exception as login_err:
            print("Something went wrong with your login credentials")
            print(login_err)
            exit(1)

        zip_paths = list(Path(packaged_grading_path).iterdir())
        print(f"Attempting to send {len(zip_paths)} emails:")
        unsuccessful_sends = []
        for zip_path in sorted(zip_paths, key=lambda path: path.name):
            student_email = zip_path.name.split('__')[0] + '@nau.edu'
            msg = EmailMessage()
            msg['To'] = student_email
            msg['From'] = email_config['address']
            msg['Subject'] = email_config['subject']
            msg.set_content(email_config['message'])
            ctype, _ = guess_type(zip_path)
            maintype, subtype = ctype.split('/')
            with open(zip_path, 'rb') as attachment_file:
                msg.add_attachment(attachment_file.read(),
                                   maintype=maintype,
                                   subtype=subtype,
                                   filename=zip_path.name)
                print(f"\tSending to {student_email} ...\t", end="")
                if not dry_run:
                    send_result = iris.send_message(msg)
            if dry_run:
                print("DRY RUN")
            elif send_result == {}:
                print("SUCCESS")
            else:
                print("FAILURE")
                unsuccessful_sends.append(student_email)

    print(f"In {len(zip_paths)} emails, there were {len(unsuccessful_sends)} "
          f"failures to send{':' if unsuccessful_sends else '.'}")
    for email_address in unsuccessful_sends:
        print(f"\t{email_address}")


set_up_command_group()
