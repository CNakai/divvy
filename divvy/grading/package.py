# TODO: Simplifying assumption make the alias always the thing immediately
# following a __
import click
from json import load
from os import mkdir
from pathlib import Path
from shutil import copy, copytree, make_archive, rmtree
from sys import exit


unassigned_gradees_notice = """
NOTICE: There were {0} students who had a submission in the submission file but
        who were not listed in the grading assignment file as a gradee.

        This likely due to either:

            1) running the 'package' command with a submission file or a
            grading assignment file that are mismatched, i.e. using a 'hwk1'
            submission file but a 'hwk2' grading assignment file or vice versa;
            this is likely if the number of unassigned gradees is high.

            2) running the 'package' command with a "fresher" version of the
            submission file than was used to generate the grading assignment
            file; you can either regenerate the grading assignment file (if you
            want to include the unassigned gradees in the grading process) or
            ignore this warning (if those students, say, made their submissions
            after the due date and you want to exclude them).
"""


@click.command()
@click.argument('submission-dir')
@click.argument('grading-assignment-file')
@click.option(
    '--per-gradee', '-e', 'per_gradee_files',
    multiple=True,
    type=click.Path(exists=True, dir_okay=False,
                    readable=True, resolve_path=True),
    help="""
    A file which should be included once for each gradee (like a blank rubric).
    This file will be copied into every gradee's submission directory in every
    grader's zip file.

    When it is copied, the filename will be changed according to the following
    scheme:

    Original name:    "hwk1_rubric.abc"
    After copy:       "hwk1_rubric__gradee_<gradee alias>.abc"

    In the sample zip file structure shown above, the files named with the
    pattern "hwk1_rubric__gradee_<alias>.docx" would all be the result of
    adding the option "-r hwk1_rubric.docx" to the run of 'package' command
    that created the zip file.

    This option can be given multiple times.
    """
)
@click.option(
    '--per-grader', '-r', 'per_grader_files',
    multiple=True,
    type=click.Path(exists=True, dir_okay=False,
                    readable=True, resolve_path=True),
    help="""
    A file which should be included once for each grader (like grading
    instructions).  This file will be copied into the folder that contains all
    the gradee submission directories in every grader's zip file.

    When it is copied, the filename will be changed according to the following
    scheme:

    Original name:    "grading_instructions.abc"
    After copy:       "grading_instructions__grader_<grader alias>.abc"

    In the sample zip file structure shown above, the files named
    "grading_instructions__grader_jkl321.docx" and
    "self_evaluation__grader_jkl321.docx" would have come from adding "-r
    grading_instructions.docx" and "-r self_evaluation.docx" to the run of the
    'package' command that created the zipfile.
    """
)
@click.option(
    '--output-dir', '-d',
    type=click.Path(file_okay=False, writable=True, resolve_path=True),
    help="""
    The directory into which the zipfiles should be placed.

    By default, the created zip files will be placed in a directory created in
    the working directory of the script with the same name as the
    SUBMISSION-DIR with "grading_zips_for__" added to the beginning.
    """
)
def package(submission_dir, grading_assignment_file, per_gradee_files,
            per_grader_files, output_dir):
    """
    SUBMISSION-DIR must be a directory where a BBLearn submission zip has been
    unpacked with the 'unpack-submission' command.

    The GRADING-ASSIGNMENT-FILE must be a .csv file where there is a column
    named "Grader".  There must also be one or more columns specifying who the
    grader will grade (the 'gradees').  The names of the gradee columns should
    be of the form "GradeeN" where "N" is a sequential integer starting at 1.
    If there are is only one gradee column it can simply be named "Gradee".
    All column names are case insensitive.

    If you used an alias map when unpacking the BBLearn submission zip into
    SUBMISSION-DIR, then the values in the columns of the
    GRADING-ASSESSMENT-FILE must be aliases since that's how the student
    submission directories were named.  If you didn't use an alias map, then
    the values in the GRADING-ASSIGNMENT-FILE should be BBLearn usernames.

    A GRADING-ASSIGNMENT-FILE that is valid for use with this command may be
    generated by using the command 'grading assign'.

    A zip file will be created for each grader specified in the
    GRADING-ASSIGNMENT-FILE.  The zip file will be named according to the
    following scheme:
        <grader's alias>_grading_for_<assignment name>
    Where the <assignment name> comes from the name of the SUBMISSION-DIR

    Each of these zip files will contain a directory with the same name as the
    zip within which everything else will be contained.  This container
    directory will contain copies of student submission directories of the
    gradees designated for the grader the zip file is named after as well as a
    copy of any file passed as a PER-GRADER-FILE.  Additionally, a copy of
    every PER-GRADEE-FILE will be placed into each of the student submission
    directories in the container directory.

    This can be seen directly in the directory tree for a sample zip file for
    the grader with the BBLearn username "jkl321" shown below.  This zip file
    would have resulted from an invocation of this command like the following:
    \b
        divvy grading package hwk1 hwk1_grading_assignments.csv \\
        -r grading_instructions.docx -r self_evaluation.docx \\
        -e hwk1_rubric.docx

    \b
    jkl321_grading_for_hwk1.zip
    └── jkl321_grading_for_hwk1
        ├── grading_instructions__grader_jkl321.docx
        ├── self_evaluation__grader_jkl321.docx
        ├── ghi789
        │   ├── submission_file3.txt
        │   ├── submission_file2.txt
        │   ├── submission_file1.txt
        │   └── hwk1_rubric__gradee_ghi789.docx
        ├── def456
        │   ├── submission_file3.txt
        │   ├── submission_file2.txt
        │   ├── submission_file1.txt
        │   └── hwk1_rubric__gradee_def456.docx
        └── abc123
            ├── submission_file3.txt
            ├── submission_file2.txt
            ├── submission_file1.txt
            └── hwk1_rubric__gradee_abc126.docx

    """
    submission_dir = Path(submission_dir)
    per_grader_files = [] if not per_grader_files else per_grader_files
    per_gradee_files = [] if not per_gradee_files else per_gradee_files

    if not submission_dir.is_dir():
        print("Whoops! {submission_dir} isn't a valid directory.")
        exit(1)

    if not output_dir:
        output_dir_name = 'grading_zips_for__' + submission_dir.name
        output_dir = submission_dir.parent.joinpath(output_dir_name)

    if not output_dir.exists():
        print(f"Creating directory {output_dir}")
        mkdir(output_dir)
        print("Done!")
    elif len(list(output_dir.iterdir())) != 0:
        print(f"The directory {output_dir} is not empty!")
        exit(1)

    # Copy submission_dir contents to output_dir
    print("Gathering student submission directories... ", end="")
    for student_submission_dir in submission_dir.iterdir():
        copytree(student_submission_dir,
                 output_dir.joinpath(student_submission_dir.name))
    print("Done!")

    # Refile into grader directories
    print("Copying student submission directories into grader directories... ",
          end="")
    # TODO change to .csv file, make this a function, and extract it to utils?
    with open(grading_assignment_file, 'r') as gaf:
        grading_assignments = load(gaf)
    gradee_to_graders = grading_assignments['gradee_to_graders']
    unassigned_gradees = refile_submissions_for_graders(output_dir,
                                                        gradee_to_graders)
    print("Done!")

    # Distribute per-grader and per-gradee files
    print("Distributing per-grader and per-gradee files... ", end="")
    distribute_grading_files(output_dir, per_grader_files, per_gradee_files)
    print("Done!")

    # Create zips
    print("Packaging grader directories... ", end="")
    package_grader_dirs(output_dir)
    print("Done!\n")

    if unassigned_gradees != []:
        print(unassigned_gradees_notice.format(len(unassigned_gradees)))
        # TODO: List unassigned gradees


def refile_submissions_for_graders(output_dir, gradee_to_graders):
    grading_dir_suffix = f"grading_for_{output_dir.name.split('__')[-1]}"
    unassigned_gradees = []
    for gradee_path in output_dir.iterdir():
        gradee_id = gradee_path.name
        grader_ids = gradee_to_graders.get(gradee_id)

        if not grader_ids:
            unassigned_gradees.append(gradee_id)
            rmtree(gradee_path)
            continue

        for grader_id in grader_ids:
            grader_dir_name = f"{grader_id}__{grading_dir_suffix}"
            grader_dir_path = output_dir.joinpath(grader_dir_name)
            if not grader_dir_path.exists():
                mkdir(grader_dir_path)
            copytree(gradee_path, grader_dir_path.joinpath(gradee_path.name))
        rmtree(gradee_path)

    return unassigned_gradees


def distribute_grading_files(output_dir, per_grader_files, per_gradee_files):
    # TODO: remove duplication
    for grader_path in output_dir.iterdir():
        # Distribute per gradee files
        for gradee_path in grader_path.iterdir():
            gradee_alias = gradee_path.name
            for per_gradee_file in per_gradee_files:
                per_gradee_path = Path(per_gradee_file)
                new_name = append_in_file_name(per_gradee_path.name,
                                               f"__gradee_{gradee_alias}")
                copy(per_gradee_path, gradee_path.joinpath(new_name))

        # Distribute grader files
        grader_alias = grader_path.name.split('__')[0]  # TODO abstract
        for per_grader_file in per_grader_files:
            per_grader_path = Path(per_grader_file)
            new_name = append_in_file_name(per_grader_path.name,
                                           f"__grader_{grader_alias}")
            copy(per_grader_path, grader_path.joinpath(new_name))


def package_grader_dirs(output_dir):
    for grader_path in output_dir.iterdir():
        make_archive(
            grader_path,
            'zip',
            root_dir=output_dir,
            base_dir=grader_path.name
        )
        rmtree(grader_path)


def append_in_file_name(file_name, appendage):
    name, file_extensions = file_name.split('.', maxsplit=1)
    return f"{name}{appendage}.{file_extensions}"
